// Generated by https://quicktype.io

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
function toUserSettings(json) {
    return cast(JSON.parse(json), o("UserSettings"));
}

function userSettingsToJson(value) {
    return JSON.stringify(value, null, 2);
}

function cast(obj, typ) {
    if (!isValid(typ, obj)) {
        throw `Invalid value`;
    }
    return obj;
}

function isValid(typ, val) {
    if (typ === undefined) return true;
    if (typ === null) return val === null || val === undefined;
    return typ.isUnion  ? isValidUnion(typ.typs, val)
            : typ.isArray  ? isValidArray(typ.typ, val)
            : typ.isMap    ? isValidMap(typ.typ, val)
            : typ.isEnum   ? isValidEnum(typ.name, val)
            : typ.isObject ? isValidObject(typ.cls, val)
            :                isValidPrimitive(typ, val);
}

function isValidPrimitive(typ, val) {
    return typeof typ === typeof val;
}

function isValidUnion(typs, val) {
    // val must validate against one typ in typs
    return typs.find(typ => isValid(typ, val)) !== undefined;
}

function isValidEnum(enumName, val) {
    const cases = typeMap[enumName];
    return cases.indexOf(val) !== -1;
}

function isValidArray(typ, val) {
    // val must be an array with no invalid elements
    return Array.isArray(val) && val.every(element => {
        return isValid(typ, element);
    });
}

function isValidMap(typ, val) {
    if (val === null || typeof val !== "object" || Array.isArray(val)) return false;
    // all values in the map must be typ
    return Object.keys(val).every(prop => {
        if (!Object.prototype.hasOwnProperty.call(val, prop)) return true;
        return isValid(typ, val[prop]);
    });
}

function isValidObject(className, val) {
    if (val === null || typeof val !== "object" || Array.isArray(val)) return false;
    let typeRep = typeMap[className];
    return Object.keys(typeRep).every(prop => {
        if (!Object.prototype.hasOwnProperty.call(typeRep, prop)) return true;
        return isValid(typeRep[prop], val[prop]);
    });
}

function a(typ) {
    return { typ, isArray: true };
}

function e(name) {
    return { name, isEnum: true };
}

function u(...typs) {
    return { typs, isUnion: true };
}

function m(typ) {
    return { typ, isMap: true };
}

function o(className) {
    return { cls: className, isObject: true };
}

const typeMap = {
    "UserSettings": {
        "window.zoomLevel": 3.14,
        "workbench.colorTheme": "",
        "editor.fontSize": 0,
        "editor.tabSize": 0,
        "prettier.tabWidth": 0,
        "editor.detectIndentation": false,
        "editor.lineHeight": 0,
        "editor.cursorStyle": "",
        "editor.multiCursorModifier": "",
        "editor.rulers": a(0),
        "vetur.format.defaultFormatter.css": "",
        "vetur.format.defaultFormatter.html": "",
        "vetur.format.defaultFormatter.js": "",
        "vetur.format.defaultFormatter.postcss": "",
        "vetur.format.defaultFormatter.scss": "",
        "vetur.format.scriptInitialIndent": false,
        "vetur.format.styleInitialIndent": false,
        "prettier.singleQuote": false,
        "prettier.trailingComma": "",
        "terminal.integrated.fontSize": 0,
        "terminal.integrated.lineHeight": 3.14,
        "terminal.integrated.cursorBlinking": false,
        "terminal.integrated.cursorStyle": "",
        "workbench.iconTheme": "",
        "files.autoSave": "",
        "files.associations": o("FilesAssociations"),
        "jshint.options": o("JshintOptions"),
        "diffEditor.ignoreTrimWhitespace": false,
        "git.autofetch": false,
    },
    "FilesAssociations": {
        "*.json": "",
        ".eslintrc": "",
    },
    "JshintOptions": {
        esversion: 0,
    },
};

module.exports = {
    "userSettingsToJson": userSettingsToJson,
    "toUserSettings": toUserSettings,
};
